<html>
	<head>
		
		<style>
			html
			{
				background:	#eee;
			}
			
			body
			{
				display:	grid;
			}
			
			#GameContainer
			{
				margin:		3em;
				padding:	3em;
				background:	#333;
				color:		#eee;
				border-radius:	1em;
			}
			
			
		</style>
		
	</head>
	
	<body>
		
		<div id=GameContainer></div>
		
		<script type=module>
			
			import {PromiseQueue,CreatePromise,Yield} from '../Games/PromiseQueue.js'
			import OfflineServer from '../Server.Js/GameServer_Offline.js'

			//	server
			import Minesweeper from '../Games/Minesweeper.js'
			import Boggle from '../Games/Boggle.js'
			
			//	client
			import GameElement_Debug from './GameElement_Debug.js'
			
			
			class LobbyApi
			{
				//	returns Player UID
				async AuthorisePlayer(PlayerName)
				{
					return `${PlayerName}_UID`;
				}
			}
		

			const Lobby = new LobbyApi();
			const LocalServerInstance = new OfflineServer();
			
			
			function OnServerLog(Message)
			{
				console.warn(`Server: ${Message}`);
			}
			function OnServerError(Message)
			{
				console.error(`Server Error: ${Message}`);
			}
			
			
			
			//	boot a game server
			async function RunGameServer(LocalServer,OnLog,OnError)
			{
				const Games = [Minesweeper,Boggle];
				
				while ( true )
				{
					const NextGameClass = Games[Math.floor(Math.random()*Games.length)];
					let Game = new NextGameClass(OnLog);
					LocalServer.Server_SetGame( Game );
					
					function OnStateChanged()
					{
						const State = Game.GetPublicState();
						LocalServer.Server_BroadcastState.call( LocalServer, State );
					}
					
					const SendMoveAndWait = LocalServer.Server_SendMoveAndWait.bind(LocalServer);
					const OnAction = LocalServer.Server_OnAction.bind(LocalServer);
					
					await Game.WaitForEnoughPlayers();
					const GameResult = await Game.RunGame( SendMoveAndWait, OnStateChanged, OnAction );
					
					OnLog(GameResult);
					LocalServer.Server_SetGame( null );
					await Yield(1*1000);
				}
			}
			RunGameServer(LocalServerInstance,OnServerLog,OnServerError).catch(OnServerError);
			
			
			
			function GetGameElementType(GameType)
			{
				switch ( GameType )
				{
					default:
					return GameElement_Debug.ElementName;
				}
			}
					
			
			
			//	boot a client
			async function RunClient(GameContainerDiv,LocalServer)
			{
				const PlayerUid = await Lobby.AuthorisePlayer(`Zaphod`);
				
				let GameElement = null;
				
				//	connect to the server
				while ( true )
				{
					//	emulate delay before a player joins
					await Yield(3*1000);
					//	connect
					await LocalServer.Client_Connect(PlayerUid);
					
					//	now just keep getting new states
					while ( true )
					{
						const NewState = await LocalServer.Client_WaitForNextState();
						
						//	if this state's game type doesn't match our current game's webcomponent type
						//	then we need to recreate it
						if ( NewState.GameType == null )
						{
							console.warn(`Warning, state without .GameType`,NewState);
						}
						else if ( !GameElement || GameElement.GameType != NewState.GameType )
						{
							GameElement?.remove();
							GameElement = null;

							GameElement = document.createElement( GetGameElementType(NewState.GameType) );
							GameContainerDiv.appendChild(GameElement);
						}
						
						//	this is new actions, rather than new state
						if ( NewState.Actions || NewState.BadMove )
						{
							const Action = NewState;
							const ActionForThisPlayer = ( Action.Player == PlayerUid );
							const Reply = await GameElement.SetAction( Action, ActionForThisPlayer );
							
							if ( Reply )
								LocalServer.Client_SendActionReply( Reply.Action, Reply.ActionArguments );

							//	any action will execute and loop around for a new state
						}
						else
						{
							//	update state of element and wait for it to finish
							await GameElement.SetState(NewState);
						}
						
					}
				}
			}
			const GameContainerDiv = document.querySelector(`#GameContainer`);
			RunClient(GameContainerDiv,LocalServerInstance).catch( console.error );
		</script>
	</body>
</html>

